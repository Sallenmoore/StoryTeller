import base64
import json
import os
from urllib.parse import urlparse

import requests
import slugify

from autonomous import log

# --- Configuration Example ---
#  set these environment variables in your .env file or Docker Compose
# TODO:  fix this later
FOUNDRY_VTT_URL = "https://foundryrelay.stevenamoore.dev/"
FOUNDRY_API_TOKEN = "855afa2a8e8f574046cda3d2c5155074"


class FoundryClient:
    """
    A client wrapper for interacting with the foundryvtt-rest-api-relay.
    """

    def __init__(
        self, world_name, base_url=FOUNDRY_VTT_URL, api_token=FOUNDRY_API_TOKEN
    ):
        """
        Initializes the client with the Foundry VTT base URL and the API token.
        Args:
            base_url (str): The URL where Foundry VTT is accessible (e.g., 'https://myfoundry.com').
            api_token (str): The API Token generated by the foundryvtt-rest-api-relay module.
        """
        # Ensure the URL is correctly formatted for the relay's base path
        self.base_url = f"{base_url.rstrip('/')}"
        self.client_id = None  # Will be set after connecting to a world
        self.headers = {
            # The API Relay requires the token to be sent in the header
            "x-api-key": api_token,
            "Content-Type": "application/json",
        }
        for client in self.get_worlds():
            print(client)
            if client["customName"].lower() in world_name.lower():
                self.client_id = client["id"]
                break
        if not self.client_id:
            raise ValueError(f"World '{world_name}' not found in Foundry VTT.")

        self.headers |= {
            "x-client-id": self.client_id,
        }

    def _request(self, method, endpoint, **kwargs):
        """Internal method to handle requests and error processing."""
        url = f"{self.base_url}/{endpoint}"
        log(url, self.headers)

        try:
            if method.upper() in ["POST", "PATCH", "PUT"]:
                # log(kwargs)
                response = requests.request(
                    method, url, headers=self.headers, json=kwargs
                )
            else:
                response = requests.request(
                    method, url, headers=self.headers, params=kwargs
                )
            # log(response.status_code, response.text, response.url)
            response.raise_for_status()  # Raise an HTTPError for bad responses (4xx or 5xx)

            # Foundry API may return text or empty content, handle JSON decoding gracefully
            if response.text:
                return response.json()
            return {}

        except requests.exceptions.HTTPError as e:
            log(
                f"HTTP Error {e.response.status_code} on {method} {url}: {e.response.text}"
            )
            raise e
        except requests.exceptions.RequestException as e:
            log(f"Network or Connection Error: {e}")
            raise e

    # --- API Methods ---

    def get_worlds(self):
        """Retrieves a list of available worlds."""
        response = self._request("GET", "clients")
        return response.get("clients", [])

    def upload_image(self, image_url, image_path):
        """Uploads an image to Foundry's assets."""
        MIME_TYPE = "image/webp"
        DATA_URL_HEADER = f"data:{MIME_TYPE};base64,"
        if "http" not in image_url:
            image_url = f"{os.environ['APP_BASE_URL']}{image_url}"
        # log("Uploading image to Foundry:", image_path, image_url)
        file_content_bytes = requests.get(image_url).content
        encoded_bytes = base64.b64encode(file_content_bytes)
        fileData_data_url = DATA_URL_HEADER + encoded_bytes.decode("utf-8")
        response = self._request(
            "POST",
            f"upload?clientId={self.client_id}",
            path=os.path.dirname(image_path),
            filename=os.path.basename(image_path),
            fileData=fileData_data_url,
            overwrite=True,
        )
        # log(response)
        return image_path

    # def get_scene(self, scene_id):
    #     """Retrieves a specific scene within a specific world."""
    #     return self._request("GET", f"get?clientId={self.client_id}", uuid=scene_id)

    # def get_actor(self, actor_id):
    #     """Retrieves a specific actor within a specific world."""
    #     return self._request("GET", f"get?clientId={self.client_id}", uuid=actor_id)

    # def get_item(self, item_id):
    #     """Retrieves a specific item within a specific world."""
    #     return self._request("GET", f"get?clientId={self.client_id}", uuid=item_id)

    def push_actor(self, obj):
        """Creates a new Foundry actor (character)."""
        actor_data = {
            "entityType": "Actor",
            "data": obj.to_foundry(),
        }

        items = []
        for item in obj.items:
            self.push_item(obj)
            if item.foundry_id:
                log("Adding item:", item.name)
                items += [{"_id": item.foundry_id}]
        for ability in obj.abilities:
            self.push_item(obj)
            if ability.foundry_id:
                log("Adding ability:", ability.name)
                items += [{"_id": ability.foundry_id}]
        actor_data["data"]["items"] = items

        if obj.image:
            actor_data["data"]["img"] = self.upload_image(
                obj.image.url(), f"/assets/images/characters/{obj.pk}.webp"
            )
            actor_data["data"]["prototypeToken"]["texture"]["src"] = actor_data["data"][
                "img"
            ]

        try:
            response = self._request(
                "PUT",
                f"update?clientId={self.client_id}&uuid={obj.foundry_id}",
                **actor_data,
            )
            log(response)
        except Exception as e:
            log("Error updating actor:", e)
            response = self._request(
                "POST", f"create?clientId={self.client_id}", **actor_data
            )
            obj.foundry_id = response.get("uuid")
            obj.save()
        return response

    def push_item(self, obj):
        """Creates a new Foundry item."""
        item_data = {
            "entityType": "Item",
            "data": obj.to_foundry(),
        }
        item_data["type"] = obj.type if obj.model_name() == "Item" else "feature"
        if obj.image:
            item_data["data"]["img"] = self.upload_image(
                obj.image.url(), f"/assets/images/items/{obj.pk}.webp"
            )

        try:
            response = self._request(
                "PUT",
                f"update?clientId={self.client_id}&uuid={obj.foundry_id}",
                **item_data,
            )
            log(response)
        except Exception as e:
            log("Error updating item:", e)
            response = self._request(
                "POST", f"create?clientId={self.client_id}", **item_data
            )
            obj.foundry_id = response.get("uuid")
            obj.save()
        return response

    def push_scene(self, obj):
        """Creates a new Foundry scene."""
        scene_data = {
            "entityType": "Scene",
            "data": obj.to_foundry(),
        }
        # Scene Background Image (maps to background.src)
        # The source is null, so we explicitly set it to null or a default path if needed.
        if obj.map:
            scene_data["data"]["background"]["src"] = self.upload_image(
                obj.map.url(), f"/assets/images/scenes/{obj.pk}.webp"
            )
            scene_data["data"]["thumb"] = scene_data["data"]["background"]["src"]

        foundry_updated = False
        if obj.foundry_id:
            response = self._request(
                "PUT",
                f"update?clientId={self.client_id}&uuid={obj.foundry_id}",
                **scene_data,
            )

            foundry_updated = True if not response.get("error") else False

        if not foundry_updated:
            response = self._request(
                "POST", f"create?clientId={self.client_id}", **scene_data
            )
            obj.foundry_id = response.get("uuid")
            obj.save()
        log(response)
        return response

    def get_scenes(self):
        """Retrieves all scenes within a specific world."""
        return self._request(
            "GET", f"search?clientId={self.client_id}", query="", filter="Scene"
        )

    def get_actors(self):
        """Retrieves all actors within a specific world."""
        results = self._request(
            "GET", f"search?clientId={self.client_id}", query="", filter="actor"
        )
        results = [
            r
            for r in results.get("results", [])
            if "compendium" not in r.get("resultType", "").lower()
        ]
        return results

    def get_items(self):
        """Retrieves all items within a specific world."""
        return self._request(
            "GET", f"search?clientId={self.client_id}", query="", filter="Item"
        )
